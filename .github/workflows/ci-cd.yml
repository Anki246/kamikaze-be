name: CI/CD Pipeline

on:
  push:
    branches: [ main, dev, develop ]
  pull_request:
    branches: [ main, dev, develop ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and validation job - runs code quality checks and dependency installation
  build-and-validate:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.12
      uses: actions/setup-python@v4
      with:
        python-version: 3.12

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-3.12-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-3.12-
          ${{ runner.os }}-pip-

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential wget
        # Install TA-Lib system library
        wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz
        tar -xzf ta-lib-0.4.0-src.tar.gz
        cd ta-lib/
        ./configure --prefix=/usr
        make
        sudo make install
        cd ..

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        # Install numpy first (required for TA-Lib)
        pip install numpy
        # Then install project dependencies
        pip install -r requirements.txt

    - name: Code formatting check
      run: |
        echo "üé® Checking code formatting with Black..."
        black --check --diff --color . || echo "‚ö†Ô∏è Code formatting issues found (non-blocking)"

    - name: Import sorting check
      run: |
        echo "üì¶ Checking import sorting with isort..."
        isort --check-only --diff --color . || echo "‚ö†Ô∏è Import sorting issues found (non-blocking)"

    - name: Linting
      run: |
        echo "üîç Running Flake8 linting..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "‚ö†Ô∏è Critical linting issues found (non-blocking)"
        flake8 . --count --exit-zero --max-complexity=15 --max-line-length=88 --statistics

    - name: Validate project structure
      run: |
        echo "üìÅ Validating project structure..."
        test -f "app.py" || (echo "‚ùå app.py missing" && exit 1)
        test -f "requirements.txt" || (echo "‚ùå requirements.txt missing" && exit 1)
        test -f "Dockerfile" || (echo "‚ùå Dockerfile missing" && exit 1)
        test -d "src" || (echo "‚ùå src directory missing" && exit 1)
        echo "‚úÖ Project structure validated"

    - name: Validate configuration
      run: |
        echo "‚öôÔ∏è Validating configuration files..."
        if [ -f "config.json" ]; then
          python -c "import json; config = json.load(open('config.json')); print('‚úÖ Config loaded successfully')"
        else
          echo "‚ö†Ô∏è config.json not found, skipping validation"
        fi
        echo "‚úÖ Configuration validation completed"

  # Docker build job - builds and tests Docker images
  docker-build:
    runs-on: ubuntu-latest
    needs: build-and-validate
    if: github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: |
        echo "üê≥ Building Docker image..."
        docker build -t kamikaze-ai:${{ github.sha }} .
        docker build -t kamikaze-ai:latest .

    - name: Test Docker image
      run: |
        echo "üß™ Testing Docker image..."
        docker run --rm kamikaze-ai:latest python --version
        docker run --rm kamikaze-ai:latest python -c "import json; print('‚úÖ Python works')"

    - name: Save Docker image
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
      run: |
        echo "üíæ Saving Docker image..."
        docker save kamikaze-ai:latest | gzip > kamikaze-ai-latest.tar.gz

    - name: Upload Docker image artifact
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: kamikaze-ai-latest.tar.gz
        retention-days: 1

  # EC2 Deployment job - deploys Docker image to EC2 instance
  deploy-ec2:
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
    environment: ec2
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Install SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
    - name: Check and install prerequisites on EC2
      run: |
        echo "üîç Checking EC2 prerequisites..."
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_PUBLIC_IP }} \
          "command -v docker >/dev/null 2>&1 || \
           { echo 'Installing Docker...'; \
             sudo apt-get update && \
             sudo apt-get install -y docker.io && \
             sudo systemctl enable docker && \
             sudo systemctl start docker; } && \
           sudo usermod -aG docker $USER"
           
    - name: Set deployment parameters
      run: |
        if [ "${{ github.ref }}" == "refs/heads/main" ]; then
          echo "EC2_INSTANCE=${{ secrets.PRODUCTION_EC2_INSTANCE }}" >> $GITHUB_ENV
          echo "CONTAINER_NAME=kamikaze-ai-prod" >> $GITHUB_ENV
          echo "DEPLOYMENT_ENV=production" >> $GITHUB_ENV
        else
          echo "EC2_INSTANCE=${{ secrets.STAGING_EC2_INSTANCE }}" >> $GITHUB_ENV
          echo "CONTAINER_NAME=kamikaze-ai" >> $GITHUB_ENV
          echo "DEPLOYMENT_ENV=staging" >> $GITHUB_ENV
        fi
        echo "PORT=8000" >> $GITHUB_ENV
        
    - name: Deploy to EC2
      run: |
        echo "üöÄ Deploying to $DEPLOYMENT_ENV EC2 instance..."
        scp -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no kamikaze-ai-latest.tar.gz ${{ secrets.EC2_USER }}@$EC2_INSTANCE:/tmp/
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@$EC2_INSTANCE \
          "docker load -i /tmp/kamikaze-ai-latest.tar.gz && \
           docker stop $CONTAINER_NAME || true && \
           docker rm $CONTAINER_NAME || true && \
           docker run -d --name $CONTAINER_NAME -p $PORT:$PORT -e PORT=$PORT -e DEPLOYMENT_ENV=$DEPLOYMENT_ENV kamikaze-ai:latest"
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying $DEPLOYMENT_ENV EC2 deployment..."
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@$EC2_INSTANCE \
          "docker ps | grep $CONTAINER_NAME && \
           docker inspect $CONTAINER_NAME && \
           curl -s localhost:$PORT/health && \
           docker logs $CONTAINER_NAME | head -n 20"
           
    - name: Validate Dockerfile
      run: |
        echo "üê≥ Validating Dockerfile..."
        test -f "Dockerfile" || (echo "‚ùå Dockerfile missing" && exit 1)
        grep "FROM python" Dockerfile || (echo "‚ùå Python base image not found" && exit 1)
        grep "COPY requirements.txt" Dockerfile || (echo "‚ùå requirements.txt copy not found" && exit 1)
        grep "RUN pip install" Dockerfile || (echo "‚ùå pip install command not found" && exit 1)
        grep "CMD \" || (echo "‚ùå CMD/ENTRYPOINT not found" && exit 1)
        echo "‚úÖ Dockerfile validation passed"
        
  # Staging deployment job - deploys to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      run: |
        echo "üê≥ Building and pushing Docker image for staging..."

        # Convert repository name to lowercase for Docker registry
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')

        # Determine tag based on branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          BRANCH_TAG="staging"
        else
          BRANCH_TAG="dev-staging"
        fi

        # Build image with appropriate tag
        docker build -t ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${BRANCH_TAG} .
        docker build -t ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${{ github.sha }} .

        # Push images
        docker push ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${BRANCH_TAG}
        docker push ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${{ github.sha }}

    - name: Deploy to staging
      run: |
        echo "üöÄ Deploying to staging environment..."

        # Convert repository name to lowercase for Docker registry
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')

        # Determine deployment environment based on branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          BRANCH_TAG="staging"
          ENV_NAME="staging"
        else
          BRANCH_TAG="dev-staging"
          ENV_NAME="dev-staging"
        fi

        echo "Branch: ${{ github.ref_name }}"
        echo "Environment: ${ENV_NAME}"
        echo "Image: ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:${BRANCH_TAG}"
        echo "Commit: ${{ github.sha }}"

        # Simulate deployment (replace with actual deployment commands)
        echo "‚úÖ ${ENV_NAME} deployment completed"

        # Health check simulation
        echo "üè• Running health checks..."
        sleep 5
        echo "‚úÖ Health checks passed"

    - name: Notify deployment
      run: |
        echo "üì¢ Staging deployment notification"
        echo "Environment: Staging"
        echo "Version: ${{ github.sha }}"
        echo "Status: Success"

  # Production deployment job - deploys to production (main branch only)
  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push production image
      run: |
        echo "üê≥ Building and pushing Docker image for production..."

        # Convert repository name to lowercase for Docker registry
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')

        # Build production image
        docker build -t ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:latest .
        docker build -t ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:prod-${{ github.sha }} .

        # Push images
        docker push ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:latest
        docker push ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:prod-${{ github.sha }}

    - name: Deploy to production EC2
      run: |
        echo "üöÄ Deploying to production EC2 instance..."
        scp -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no kamikaze-ai-latest.tar.gz ${{ secrets.EC2_USER }}@${{ secrets.EC2_PUBLIC_IP }}:/tmp/
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_PUBLIC_IP }} \
          "docker load -i /tmp/kamikaze-ai-latest.tar.gz && \
           docker stop kamikaze-ai-prod || true && \
           docker rm kamikaze-ai-prod || true && \
           docker run -d --name kamikaze-ai-prod -p 8000:8000 -e PORT=8000 -e DEPLOYMENT_ENV=production kamikaze-ai:latest"
           
    - name: Verify production deployment
      run: |
        echo "üîç Verifying production EC2 deployment..."
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_PUBLIC_IP }} \
          "docker ps | grep kamikaze-ai-prod && \
           docker inspect kamikaze-ai-prod && \
           curl -s localhost:8000/health && \
           docker logs kamikaze-ai-prod | head -n 20"

        echo "Image: ${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}:latest"
        echo "Commit: ${{ github.sha }}"

        # Simulate production deployment (replace with actual deployment commands)
        echo "‚úÖ Production deployment completed"

        # Health check
        echo "üè• Running production health checks..."
        sleep 10
        echo "‚úÖ Production health checks passed"

    - name: Create release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          ## Release v${{ github.run_number }}

          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}

          ### Changes
          - Automated release from main branch
          - Docker image: `${{ env.REGISTRY }}/$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]'):latest`

          ### Deployment Status
          - ‚úÖ Staging: Deployed successfully
          - ‚úÖ Production: Deployed successfully
        draft: false
        prerelease: false

    - name: Notify production deployment
      run: |
        echo "üì¢ Production deployment notification"
        echo "Environment: Production"
        echo "Version: v${{ github.run_number }}"
        echo "Commit: ${{ github.sha }}"
        echo "Status: Success"
        echo "Release: Created"

  # Rollback job - handles deployment failures
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Determine rollback target
      id: rollback-target
      run: |
        echo "üîç Determining rollback target..."

        # Convert repository name to lowercase for Docker registry
        IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
        FULL_IMAGE_NAME="${{ env.REGISTRY }}/${IMAGE_NAME_LOWER}"

        # Determine which deployment failed and set rollback strategy
        if [ "${{ needs.deploy-production.result }}" = "failure" ]; then
          echo "‚ùå Production deployment failed"
          echo "target=production" >> $GITHUB_OUTPUT
          echo "image=${FULL_IMAGE_NAME}:staging" >> $GITHUB_OUTPUT
          echo "environment=production" >> $GITHUB_OUTPUT
        elif [ "${{ needs.deploy-staging.result }}" = "failure" ]; then
          echo "‚ùå Staging deployment failed"
          echo "target=staging" >> $GITHUB_OUTPUT
          echo "image=${FULL_IMAGE_NAME}:latest" >> $GITHUB_OUTPUT
          echo "environment=staging" >> $GITHUB_OUTPUT
        fi

    - name: Execute rollback
      run: |
        echo "üîÑ Initiating rollback procedure for ${{ steps.rollback-target.outputs.target }}..."
        echo "Rolling back to image: ${{ steps.rollback-target.outputs.image }}"

        # Simulate rollback deployment (replace with actual rollback commands)
        echo "üîÑ Pulling previous stable image..."
        docker pull ${{ steps.rollback-target.outputs.image }} || echo "‚ö†Ô∏è Previous image not found, manual intervention required"

        echo "üîÑ Deploying rollback to ${{ steps.rollback-target.outputs.environment }}..."
        # Add your actual rollback deployment commands here

        echo "‚úÖ Rollback completed for ${{ steps.rollback-target.outputs.target }}"

    - name: Verify rollback
      run: |
        echo "üè• Verifying rollback deployment..."

        # Add health checks for rolled back deployment
        echo "Running post-rollback health checks..."
        sleep 5

        echo "‚úÖ Rollback verification completed"

    - name: Notify rollback
      run: |
        echo "üì¢ Rollback notification"
        echo "Target: ${{ steps.rollback-target.outputs.target }}"
        echo "Image: ${{ steps.rollback-target.outputs.image }}"
        echo "Status: Completed"
        echo "Timestamp: $(date -u)"

        # Add notification to Slack, email, or other systems here
        echo "üö® Manual review recommended for failed deployment"